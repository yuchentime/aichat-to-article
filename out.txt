import { generateArticle } from '../api/chatApi';
import { logger } from '../lib/logger';

// åˆ›å»ºå³é”®èœå•ï¼Œä»…åœ¨æŒ‡å®šåŸŸåä¸‹æ˜¾ç¤º
const allowedHosts = ['chatgpt.com', 'grok.com'];

const taskQueue: Task[] = [];
const taskState: Record<'pending' | 'running' | 'finished', Task[]> = {
  pending: [],
  running: [],
  finished: []
};

let processing = false;

// Track whether we've hydrated from storage at least once in this SW lifetime
let hydrated = false;

// Merge storage state with in-memory state, preferring in-memory on conflicts.
const hydrateState = async () => {
  try {
    const stored = await chrome.storage.local.get('tasks');
    const persisted: Record<'pending' | 'running' | 'finished', Task[]> = stored?.tasks || { pending: [], running: [], finished: [] };

    // Build a unified map by id; prefer current (in-memory) snapshot when duplicated
    const allPersisted = [...(persisted.pending || []), ...(persisted.running || []), ...(persisted.finished || [])];
    const allCurrent = [...taskState.pending, ...taskState.running, ...taskState.finished];
    const map = new Map<string, Task>();
    for (const t of allPersisted) map.set(t.id, t);
    for (const t of allCurrent) map.set(t.id, t); // in-memory wins

    const next: Record<'pending' | 'running' | 'finished', Task[]> = { pending: [], running: [], finished: [] };
    for (const t of map.values()) {
      // Trust each task's status to place it in the correct bucket
      if (t.status === 'pending') next.pending.push(t);
      else if (t.status === 'running') next.running.push(t);
      else next.finished.push(t);
    }

    taskState.pending = next.pending;
    taskState.running = next.running;
    taskState.finished = next.finished;
    hydrated = true;
    logger.background.info('å·²ä»å­˜å‚¨ä¸­hydrateä»»åŠ¡çŠ¶æ€?, {
      pending: taskState.pending.length,
      running: taskState.running.length,
      finished: taskState.finished.length,
    });
  } catch (e) {
    logger.background.error('hydrateä»»åŠ¡çŠ¶æ€å¤±è´?, { error: String(e) });
  }
};

// todo åé¢æ”¹ç”¨ IndexedDB
const saveState = async () => {
  if (!hydrated) {
    await hydrateState();
  }
  // After ensuring we are merged with persisted state, write back
  logger.background.info('ä¿å­˜ä»»åŠ¡çŠ¶æ€?, {
    pending: taskState.pending.length,
    running: taskState.running.length,
    finished: taskState.finished.length,
  });
  await chrome.storage.local.set({ tasks: taskState });
  logger.background.info('ä»»åŠ¡çŠ¶æ€å·²ä¿å­˜åˆ°å­˜å‚?);
};

// ä¿å­˜ï¼šä»¥å˜é‡ id ä½œä¸ºé”®åï¼›ç”¨ try/catch è®©è°ƒç”¨æ–¹èƒ?await/æ•è·é”™è¯¯
const saveResult = async (id: string, result: string): Promise<void> => {
  logger.background.info('ä¿å­˜ä»»åŠ¡ç»“æœ', { id, result });
  try {
    await chrome.storage.local.set({ [id]: result });
    logger.background.info('ä»»åŠ¡ç»“æœå·²ä¿å­˜åˆ°å­˜å‚¨', { id });
  } catch (error) {
    logger.background.error('ä¿å­˜ä»»åŠ¡ç»“æœå¤±è´¥', { id, error: String(error) });
    throw error; // è®©è°ƒç”¨æ–¹å¯æ„ŸçŸ¥å¤±è´?
  }
};

// è¯»å–ï¼šåŒºåˆ†â€œæœªæ‰¾åˆ°â€å’Œâ€œç©ºå­—ç¬¦ä¸²â€ï¼›å¹¶æ•è·å¼‚å¸?
const getResult = async (id: string): Promise<string | null> => {
  logger.background.info('è·å–ä»»åŠ¡ç»“æœ', { id });
  try {
    const stored = await chrome.storage.local.get(id); // å½¢å¦‚ { [id]: value } æˆ?{}
    if (Object.prototype.hasOwnProperty.call(stored, id)) {
      logger.background.info('ä»»åŠ¡ç»“æœå·²ä»å­˜å‚¨ä¸­è·å?, { id });
      return stored[id] as string; // å¯èƒ½æ˜¯ç©ºå­—ç¬¦ä¸?""
    }
    logger.background.warn('æœªæ‰¾åˆ°ä»»åŠ¡ç»“æ?, { id });
    return null;
  } catch (error) {
    logger.background.error('è¯»å–ä»»åŠ¡ç»“æœå¤±è´¥', { id, error: String(error) });
    return null; // æˆ–è€…é€‰æ‹© throwï¼Œè®©ä¸Šå±‚å¤„ç†
  }
};

const sendNotification = (title: string, message: string) => {
  // æ£€æŸ¥æµè§ˆå™¨é€šçŸ¥æƒé™
  chrome.notifications.getPermissionLevel((level) => {
    logger.background.info('é€šçŸ¥æƒé™çº§åˆ«', { level });

    if (level === 'denied') {
      logger.background.warn('æµè§ˆå™¨é€šçŸ¥æƒé™è¢«æ‹’ç»?);
      return;
    }

    // ä½¿ç”¨ä¸?manifest ä¸­ä¸€è‡´çš„æ‰“åŒ…å†…èµ„æºè·¯å¾?
    const iconUrl = chrome.runtime.getURL('src/assets/img/icon-128.png');
    const options: chrome.notifications.NotificationOptions = {
      type: 'basic',
      title,
      message,
      priority: 2,
      iconUrl, // å¯¹äº basic ç±»å‹ï¼ŒiconUrl æ˜¯å¿…å¡?
    } as any;

    logger.background.info('åˆ›å»ºé€šçŸ¥', { title, message, iconUrl });

    chrome.notifications.create(options, (notificationId) => {
      const lastError = chrome.runtime.lastError?.message;
      if (lastError) {
        logger.background.error('é€šçŸ¥å‘é€å¤±è´?, { error: lastError, title, message, iconUrl });
        return;
      }
      if (notificationId) {
        logger.background.info('é€šçŸ¥å‘é€æˆåŠ?, { notificationId, title, message });
      } else {
        logger.background.error('é€šçŸ¥å‘é€å¤±è´¥ï¼ˆæœªçŸ¥åŸå› ï¼?, { title, message });
      }
    });
  });
}

const runGenerateArticleTask = async (task: Task) => {
  logger.background.info('å¼€å§‹æ‰§è¡Œä»»åŠ?, { taskId: task.id, action: task.action, domain: task.domain });
  
  const finalize = async (result?: string, error?: string) => {
    logger.background.info('å®Œæˆä»»åŠ¡å¤„ç†', { taskId: task.id, hasResult: !!result, hasError: !!error });
    taskState.running = taskState.running.filter(t => t.id !== task.id);
    task.status = 'finished';
    try {
      if (result) {
        const summary = [];
        const originalSummary = result.slice(0, 200).trim();
        const summaryLines = originalSummary.split('\n');
        for (let i=0; i < summaryLines.length; i++) {
          const line = summaryLines[i];
          if(line.trim() === '\n' || line.trim() === '') {
            continue;
          }
          if (line.trim().startsWith('##') || line.trim().startsWith('#')) {
            if (!task.title) task.title = line.trim().replace(/#/g, ' ').trim();
            continue;
          }
          summary.push(line.trim());
        }
        task.summary = summary.join('\n'); // ç®€å•æ‘˜è¦ï¼Œå®é™…å¯ç”¨æ›´å¤æ‚çš„é€»è¾‘
        try {
          await saveResult(task.id, result);
        } catch (e) {
          logger.background.error('ä¿å­˜ä»»åŠ¡ç»“æœå¤±è´¥', { taskId: task.id, error: String(e) });
        }
      }
      if (error) task.error = error;
      taskState.finished.push(task);

      setBadgeText(String(taskState.running.length + taskState.pending.length));

      // å‘é€æµè§ˆå™¨é€šçŸ¥
      if (result) {
        sendNotification('ä»»åŠ¡å®Œæˆ', 'æ–‡ç« å·²ç»ç”Ÿæˆï¼Œè¯·æ‰“å¼€SidePanelæŸ¥çœ‹ã€?);
      } else if (error) {
        sendNotification('ä»»åŠ¡å¤±è´¥', error || 'ä»»åŠ¡æ‰§è¡Œå¤±è´¥ã€?);
      }

      logger.background.info('ä»»åŠ¡çŠ¶æ€å·²æ›´æ–°ä¸ºå·²å®Œæˆ', { taskId: task.id });
      try {
        await saveState();
      } catch (e) {
        logger.background.error('ä¿å­˜ä»»åŠ¡çŠ¶æ€å¤±è´?, { taskId: task.id, error: String(e) });
      }

      logger.background.info('å‘é€é˜Ÿåˆ—è¿›åº¦æ¶ˆæ?, { task });
    } finally {
      processing = false;
      logger.background.info('ç»§ç»­å¤„ç†é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªä»»åŠ?);
      processQueue();
    }
  };

  const lang = navigator.language || navigator.languages?.[0] || 'en';
  try {
    logger.background.info('è°ƒç”¨ç”Ÿæˆå‡½æ•°', { domain: task.domain });
    const userInput = task.messages.join('\n');
    let result = await generateArticle(userInput, lang);
    logger.background.info('ç”Ÿæˆç»“æœ: ', result);
    await finalize(result);
    logger.background.info('ä»»åŠ¡æ‰§è¡ŒæˆåŠŸ', { taskId: task.id });
  } catch (e) {
    const errMsg = e instanceof Error ? e.message : String(e);
    logger.background.error('ä»»åŠ¡æ‰§è¡Œé”™è¯¯', { taskId: task.id, error: errMsg });
    await finalize(undefined, errMsg);
  }

};

// è®¾ç½®badgeæ–‡æœ¬
const setBadgeText = (text: string) => {
  chrome.action.setBadgeText({ text });
  if (text) {
    chrome.action.setBadgeBackgroundColor({ color: '#f25f20ff' });
  } else {
    chrome.action.setBadgeBackgroundColor({ color: '#808080' });
  }
}

const processQueue = async () => {
  logger.background.info('å¤„ç†ä»»åŠ¡é˜Ÿåˆ—', { queueLength: taskQueue.length, processing });
  if (processing) {
    logger.background.info('å·²æœ‰ä»»åŠ¡æ­£åœ¨å¤„ç†ï¼Œè·³è¿?);
    return;
  }
  
  const task = taskQueue.shift();
  if (!task) {
    logger.background.info('é˜Ÿåˆ—ä¸ºç©ºï¼Œæ— ä»»åŠ¡å¯å¤„ç?);
    return;
  }
  
  logger.background.info('å¼€å§‹å¤„ç†ä»»åŠ?, { taskId: task.id, action: task.action });
  processing = true;

  taskState.pending = taskState.pending.filter(t => t.id !== task.id);
  task.status = 'running';
  taskState.running.push(task);
  
  setBadgeText(String(taskState.running.length + taskState.pending.length));

  logger.background.info('ä»»åŠ¡çŠ¶æ€å·²æ›´æ–°ä¸ºè¿è¡Œä¸­', { taskId: task.id });
  try {
    await saveState();
  } catch (e) {
    logger.background.error('ä¿å­˜ä»»åŠ¡çŠ¶æ€å¤±è´?, { taskId: task.id, error: String(e) });
  }

  logger.background.info('å‘é€é˜Ÿåˆ—è¿›åº¦æ¶ˆæ?, { task });

  // åœ?MV3 çš„æ‰©å±?Service Worker ä¸­ï¼Œåˆ›å»º Web Worker å­˜åœ¨å…¼å®¹æ€?æƒé™é™åˆ¶ã€?
  // ä¸ºä¿è¯ç¨³å®šæ€§ï¼Œç›´æ¥åœ?Service Worker ä¸»çº¿ç¨‹æ‰§è¡Œä»»åŠ¡ã€?
  if (task.action === 'generateArticle') {
    runGenerateArticleTask(task)
      .catch(async (e) => {
        const errMsg = e instanceof Error ? e.message : String(e);
        logger.background.error('ä»»åŠ¡æ‰§è¡Œè¿‡ç¨‹ä¸­å‡ºç°æœªæ•è·çš„å¼‚å¸?, { taskId: task.id, error: errMsg });
        sendNotification('ä»»åŠ¡å¤±è´¥', 'ä»»åŠ¡æ‰§è¡Œå¤±è´¥ã€?);
        taskState.running = taskState.running.filter(t => t.id !== task.id);
        task.status = 'finished';
        task.error = errMsg;
        taskState.finished.push(task);
        try {
          await saveState();
        } catch (err) {
          logger.background.error('ä¿å­˜ä»»åŠ¡çŠ¶æ€å¤±è´?, { taskId: task.id, error: String(err) });
        }
        processing = false;
        processQueue();
      });
  } else if (task.action === 'directSave') {

  }
};

// è·Ÿè¸ªä¾§è¾¹æ çŠ¶æ€?
let sidePanelOpen = false;

chrome.action.onClicked.addListener((tab) => {
  // åˆ‡æ¢ä¾§è¾¹æ çŠ¶æ€?
  if (sidePanelOpen) {
    // å…³é—­ä¾§è¾¹æ ?
    chrome.sidePanel.setPanelBehavior({openPanelOnActionClick: false});
    sidePanelOpen = false;
  } else {
    // æ‰“å¼€ä¾§è¾¹æ ?
    chrome.sidePanel.setPanelBehavior({openPanelOnActionClick: true});
    sidePanelOpen = true;
  }
});

chrome.runtime.onInstalled.addListener(() => {
  // Try hydrating early on install/update
  void hydrateState();
  const documentUrlPatterns = allowedHosts.map(host => `*://${host}/*`);
  chrome.contextMenus.create({
    id: 'save_to_notion',
    title: 'Save to Notion',
    contexts: ['all'],
    documentUrlPatterns,
  });

  // chrome.contextMenus.create({
  //   id: 'save_directly',
  //   parentId: 'save_to_notion',
  //   title: 'Save directly',
  //   contexts: ['all'],
  //   documentUrlPatterns,
  // });
  // chrome.contextMenus.create({
  //   id: 'generate_post',
  //   parentId: 'save_to_notion',
  //   title: 'Generate Post',
  //   contexts: ['all'],
  //   documentUrlPatterns,
  // });
});

// Hydrate on browser startup to reduce first-write races
chrome.runtime.onStartup?.addListener(() => {
  void hydrateState();
});

chrome.contextMenus.onClicked.addListener((info, tab) => {
  if (!tab || typeof tab.id === 'undefined') return;
  if (info.menuItemId === 'save_to_notion') {
    chrome.tabs.sendMessage(tab.id, { type: 'saveToNotion', action: 'generateArticle' });
  } 
  // else if (info.menuItemId === 'save_directly') {
  //   chrome.tabs.sendMessage(tab.id, { type: 'saveToNotion', action: 'directSave' });
  // }
});


chrome.runtime.onMessage.addListener((
  message: any,
  sender: chrome.runtime.MessageSender,
  sendResponse: (response?: any) => void
): boolean => {
  logger.background.info('æ”¶åˆ°æ¶ˆæ¯', message);
  const respond = (payload?: any) => (sendResponse as unknown as (response?: any) => void)(payload);
  if ((message as any)?.ping) {
    console.log('[background] received ping from', sender?.id, 'at', (message as any).ping);
    respond({ pong: Date.now() });
    return false;
  }
  const action = (message as any)?.action
  if (action === 'generateArticle') {
    const { domain, messages, taskId, url } = (message as any).payload || {};
    if (!domain || !messages || !Array.isArray(messages) || !taskId) {
      respond({ ok: false, error: 'Invalid payload' });
      return false;
    }
    logger.background.info(`æ”¶åˆ°ä»»åŠ¡è¯·æ±‚ï¼?{taskId}, åŸŸåï¼?{domain}, æ¶ˆæ¯æ•°é‡ï¼?{messages.length}`);
    if (taskQueue.some(t => t.taskId === taskId && (t.status === 'pending' || t.status === 'running'))) {
      logger.background.warn(`ä»»åŠ¡å·²å­˜åœ¨ï¼Œè·³è¿‡æ·»åŠ ï¼?{taskId}`);
      respond({ ok: false, error: 'Task already exists' });
      return false;
    }

    submitTask(domain, url, messages, taskId, 'generateArticle', respond);

    // Return true to indicate we'll respond asynchronously
    return true;
  } else if ((message as any)?.action === 'directSave') {

    return true;
  } else if((message as any)?.type === 'getResultById') {
    getResult((message as any).id).then((result) => {
      if (result) {
        respond({ ok: true, result });
      } else {
        respond({ ok: false, error: 'Result not found' });
      }
    }).catch((error) => {
      logger.background.error('è·å–ç»“æœå¤±è´¥', { id: (message as any).id, error: String(error) });
      respond({ ok: false, error: String(error) });
    });
    return true; // Keep message channel open for async response
  }

  return false;
});

const submitTask = async (domain: string, url: string, messages: string[], taskId: string
  , action: 'generateArticle' | 'directSave', respond: any) => {
    try {
      const { apiConfig } = await chrome.storage.local.get('apiConfig');
      logger.background.info('è·å–APIé…ç½®', { apiConfig });
      
      if (!apiConfig || (Array.isArray(apiConfig) && apiConfig.length === 0)) {
        logger.background.error('æ²¡æœ‰å¯ç”¨çš„APIé…ç½®');
        respond({ ok: false, error: 'No API configuration available' });
        return;
      }
      
      // æµ‹è¯•é€šçŸ¥åŠŸèƒ½
      const testNotification = () => {
        logger.background.info('æµ‹è¯•é€šçŸ¥åŠŸèƒ½');
        sendNotification('æµ‹è¯•é€šçŸ¥', 'è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•é€šçŸ¥ï¼Œç”¨äºéªŒè¯é€šçŸ¥åŠŸèƒ½æ˜¯å¦æ­£å¸¸å·¥ä½œ');
      };
      
      // æ·»åŠ æµ‹è¯•å‘½ä»¤åˆ°æ¶ˆæ¯ç›‘å¬å™¨
      chrome.runtime.onMessage.addListener((message: any) => {
        // ... ç°æœ‰çš„æ¶ˆæ¯å¤„ç†ä»£ç ?...
        
        // æ·»åŠ æµ‹è¯•é€šçŸ¥çš„å‘½ä»?
        if (message.type === 'testNotification') {
          testNotification();
          return true;
        }
        
        return false;
      });
      
      let configs: any[] = [];
      if (Array.isArray(apiConfig)) configs = apiConfig;
      else if (apiConfig) configs = [apiConfig];
      const current = configs.find((c: any) => c.currentUsing) || configs[0] || {};
      const task: QueueTask = {
        id: `task-${Date.now()}`,
        taskId,
        action,
        domain,
        model: current.model || '',
        status: 'pending',
        messages,
        synced: false,
        url
      };
      taskQueue.push(task);
      taskState.pending.push(task);
      
      await saveState();
      processQueue();
      respond({ ok: true, id: taskId });
    } catch (err) {
      logger.background.error('è·å–é…ç½®å¤±è´¥', err);
      sendNotification('ä»»åŠ¡å¤±è´¥', 'ä»»åŠ¡æ‰§è¡Œå¤±è´¥ã€?);
      respond({ ok: false, error: String(err) });
    }
}

